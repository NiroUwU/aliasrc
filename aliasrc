#!/bin/bash

CONFIG_variables='# This file was automatically generated by your aliasrc file!\n
# For the full list of configurable variables, please refer to your aliasrc source code!

# Repository Location:
PATH_repository="https://raw.githubusercontent.com/NiroUwU/aliasrc/main/aliasrc"

# Directory Paths:
PATH_cache=~/.cache/aliasrc
PATH_backup="$PATH_cache/backup"
PATH_programs=~/Programs
PATH_profile=~/profile
	
# File Paths:
PATH_aliasrc=~/aliasrc
PATH_alias_list=~/alias_list

# Aliasrc Colours:
COL_reset="\\e[0m"
COL_error="\\e[31m"
COL_warning="\\e[33m"
COL_update="\\e[33m"

# Aliashelp Title text and Colours:
TEXT_alias="Alias:        "
TEXT_desc="Description:  "
TEXT_exec="Execution:    "

COL_title_alias="\\e[1;35m"
COL_title_desc="\\e[1;35m"
COL_title_exec="\\e[1;35m"

COL_info_alias="\\e[1;4;37m"
COL_info_desc="\\e[m"
COL_info_exec="\\e[30m"
'



# VARIABLES:

# LOAD CUSTOM CONFIG FILE:
PATH_config=~/.config/aliasrc.config
[ -f "$PATH_config" ]  || ( echo -e "#!/bin/bash\n$CONFIG_variables" > $PATH_config && echo -e "Created config file in '$PATH_config'" && chmod +x $PATH_config )
# shellcheck source=/dev/null
source "$PATH_config"

# Repository Location:
[ "$PATH_repository" ] || PATH_repository="https://raw.githubusercontent.com/NiroUwU/aliasrc/main/aliasrc"

# Directory Paths:
[ "$PATH_cache" ]      || PATH_cache=~/.cache/aliasrc
[ "$PATH_backup" ]     || PATH_backup="$PATH_cache/backup"
[ "$PATH_programs" ]   || PATH_programs=~/Programs
	
# File Paths:
[ "$PATH_aliasrc" ]    || PATH_aliasrc=~/aliasrc
[ "$PATH_alias_list" ] || PATH_alias_list=~/alias_list
[ "$PATH_profile" ]    || PATH_profile=~/profile

# Aliasrc Colours:
[ "$COL_reset" ]       || COL_reset="\\e[0m"
[ "$COL_error" ]       || COL_error="\\e[31m"
[ "$COL_warning" ]     || COL_warning="\\e[33m"
[ "$COL_update" ]      || COL_update="\\e[33m"

# Aliashelp Title text and Colours:
[ "$TEXT_alias" ]      || TEXT_alias="Alias:        "
[ "$TEXT_desc" ]       || TEXT_desc="Description:  "
[ "$TEXT_exec" ]       || TEXT_exec="Execution:    "

[ "$COL_title_alias" ] || COL_title_alias="\\e[1;35m"
[ "$COL_title_desc" ]  || COL_title_desc="\\e[1;35m"
[ "$COL_title_exec" ]  || COL_title_exec="\\e[1;35m"

[ "$COL_info_alias" ]  || COL_info_alias="\\e[1;4;37m"
[ "$COL_info_desc" ]   || COL_info_desc="\\e[m"
[ "$COL_info_exec" ]   || COL_info_exec="\\e[30m"



# CHECKS FOR VALID PATHS:

# Check if cache path is valid:
[ -d "$PATH_cache" ]   || mkdir "$PATH_cache"
[ -d "$PATH_backup" ]  || mkdir "$PATH_backup"

# Check if alias source file is valid:
[ -f "$PATH_alias_list" ] || ( echo -e "#!/bin/bash\n# This file is autogenerated by your aliasrc!\n# Syntax:\n# cmd [ALIAS] [EXECUTE THIS] [DESCRIPTION]\n# pgm [ALIAS] [PATH TO EXECUTABLE] [DESCRIPTION] [optional: CUSTOMPATH (if left empty defaults to programs directory)]" > "$PATH_alias_list" && echo -e "Generated $PATH_alias_list! Read it for further information :)" )


# PRINT COLOURED TEXT:

# Print stuff coloured more easily:
function printcoloured() {
	local COL=$1
	local TXT=$2

	printf "$COL $TXT$COL_reset"
}
function echocoloured() {
	printcoloured "$1" "$2\n"
}



# MAIN FUNCTIONS:

# Functions to add aliases:
function cmd() {
	local alias_name="$1"
	local alias_exec="$2"
	local alias_desc="$3"

	# Create cache:
	echo -e "#!/bin/bash\n#NOTE: This files is autogenerated by your aliasrc!\nalias_name='$alias_name'\nalias_exec='$alias_exec'\nalias_desc='$alias_desc'" > "$PATH_cache"/"$alias_name".alias
	# Create alias for shell session:
	alias "$alias_name"="$alias_exec"
}
function pgm() {
	local PATH_full=$2

	# Custom path if $4 provided (defaults to $PATH_programs otherwise)
	local custompath=$4
	[ -z "$custompath" ] && PATH_full=$PATH_programs/$PATH_full || PATH_full=$custompath/$PATH_full

	# Check if executable is valid:
	[ -f "$PATH_full" ] || ( echo -e "Error loading alias for â€™$1': executable at '$PATH_full' could not be located!" && return )

	# Add alias:
	cmd "$1" "$PATH_full" "$3"
}



# ALIASRC COMMANDS/FUNCTIONS:

# Aliasrc help commands:
function aliashelp() {
	# Get info from an alias file:
	function displayInfo() {
		local file="$1"

		# Check if alias cache file exists:
		[ -f "$file" ] || echo -e "Alias not found at '$file'"
		[ -f "$file" ] || return 1

		# Source alias information:
		local alias_name=""
		local alias_exec=""
		local alias_desc=""

		# shellcheck source=/dev/null
		source "$file" && echo -e "$COL_title_alias$TEXT_alias$COL_reset$COL_info_alias$alias_name$COL_reset\n$COL_title_desc$TEXT_desc$COL_reset$COL_info_desc$alias_desc$COL_reset\n$COL_title_exec$TEXT_exec$COL_reset$COL_info_exec$alias_exec$COL_reset"
	}

	local these=$@
	local operation=""

	[ "$these" ] && operation="request_specific" || operation="display_all"

	# Execute operation:
	case "$operation" in
		display_all)
			local all_files=("$PATH_cache"/*.alias)
			for file in "${all_files[@]}"; do
				displayInfo "$file" && printf "\n"
			done
			echo -e "Aliashelp files are generated automatically in '$PATH_cache'."
			;;

		request_specific)
			for this in "$@"; do
				local file="$PATH_cache/$this.alias"
				displayInfo "$file" && printf "\n"
			done
			;;

	esac
}

# Update aliasrc to latest version from repository:
function aliasrc_update() {
	local CONTINUE=1
	function askForConsent() {
		read -r response
		if [[ ! "$response" == "y" && ! "$response" == "Y" ]]; then
			CONTINUE=0 && echo -e "Aborting Update."
		fi
	}
	# Aliasrc source:
	local update_url="$PATH_repository"
	
	echocoloured "$COL_update" "Fetching Repository '$update_url'\n"
	local NEW && NEW=$(curl "$update_url")
	local OLD && OLD=$(curl file:"$PATH_aliasrc")

	# No differences found, return:
	[[ "$NEW" == "$OLD" ]] && echo -e "\nYour aliasrc is up-to date! Quitting Update. :)" && return 0

	# Differences found, asking to update:
	printf "A new version was found, do you wish to update? [Y/n] " && askForConsent
	[ $CONTINUE -eq 1 ] || return

	# Weird stuff going on with curl, asking user:
	local LENGTH_old=${#OLD}
	local LENGTH_new=${#NEW}
	[ "$LENGTH_new" -lt $((LENGTH_old / 3)) ] && 
		echo -e "\n>>> Start of fetched data:\n\n$COL_error$NEW$COL_reset\n\n>>> End of fetched data\n" &&
		printcoloured "$COL_error" "WARNING: Fetched possibly corrupted or wrong file! Continue anyways? [y/N] " && askForConsent
	[ $CONTINUE -eq 1 ] || return

	# Backup current aliasrc:
	local backup_time && backup_time=$(date +%Y-%m-%d_%H:%M:%S)
	local backup_name="$PATH_backup/aliasrc.backupfrom_$backup_time"

	function attemptBackup() {
		echo -e "$OLD" > "$backup_name" || return 1
		echo -e "Backed up current aliasrc to '$backup_name'."
	}
	function backupFailedCatch() {
		printf "WARNING: Backup failed, do you wish to proceed anyways? [y/N] " && askForConsent
	}
	attemptBackup || backupFailedCatch
	[ $CONTINUE -eq 1 ] || return

	echo "$NEW" > "$PATH_aliasrc" && echo "Update complete. Refresh aliasrc (aliasrc_refresh) or restart current session to apply changes." || echo -e "Update Failed."
}

# Clears all .alias files in cache directory
function aliasrc_clearcache() {
	rm "$PATH_cache"/*.alias
}



# EXECUTE COMMANDS:

# Clear cache before import:
if [[ -f "$PATH_cache"/*.alias ]]; then
	aliasrc_clearcache
fi


# ALIASRC COMMANDS:

cmd "aliashelp"          "aliashelp" "Displays help information about added aliases."
cmd "aliasrc_clearcache" "aliasrc_clearcache" "Clears cached alias files in '$PATH_cache'."
cmd "aliasrc_update"     "aliasrc_update" "Updates aliasrc, if new version is available."
cmd "aliasrc_refresh"    '(source \"$PATH_aliasrc\" && echo -e "Aliasrc\ refreshed!"") || (echo -e "Aliasrc could not be refreshed...")' "Refreshes your aliases"

# Load profile file:
if [[ -f "$PATH_profile" ]]; then
	# shellcheck source=/dev/null
	source "$PATH_profile" || echo -e "There was an error loading your profile file at '$PATH_profile'!"
fi

# Load user aliases:
# shellcheck source=/dev/null
source "$PATH_alias_list"  || echo -e "There was an error loading your alias list file at '$PATH_alias_list'!"
